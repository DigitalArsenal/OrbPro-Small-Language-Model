#!/usr/bin/env node
/**
 * Generate C++ headers from FlatBuffers schema using flatc-wasm
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECT_DIR = path.dirname(__dirname);
const SCHEMAS_DIR = path.join(PROJECT_DIR, 'schemas');
const OUTPUT_DIR = path.join(PROJECT_DIR, 'include', 'generated');

async function main() {
    console.log('===========================================');
    console.log('Generating C++ headers from FlatBuffers');
    console.log('===========================================\n');

    // Create output directory
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // Find all .fbs files
    const schemaFiles = fs.readdirSync(SCHEMAS_DIR)
        .filter(f => f.endsWith('.fbs'))
        .map(f => path.join(SCHEMAS_DIR, f));

    if (schemaFiles.length === 0) {
        console.log('No .fbs files found in schemas/');
        return;
    }

    console.log(`Found ${schemaFiles.length} schema file(s):`);
    schemaFiles.forEach(f => console.log(`  - ${path.basename(f)}`));
    console.log('');

    // Try to use FlatcRunner from flatc-wasm
    let runner = null;
    try {
        const flatcModule = await import('flatc-wasm');
        if (flatcModule.FlatcRunner) {
            runner = new flatcModule.FlatcRunner();
            await runner.init();
            console.log('Using flatc-wasm FlatcRunner\n');
        }
    } catch (e) {
        console.log(`Note: flatc-wasm not fully available (${e.message})`);
        console.log('Using fallback header generation\n');
    }

    for (const schemaPath of schemaFiles) {
        const schemaName = path.basename(schemaPath, '.fbs');
        console.log(`Processing: ${schemaName}.fbs`);

        // Read schema content
        const schemaContent = fs.readFileSync(schemaPath, 'utf-8');

        let generated = false;

        if (runner) {
            try {
                const result = await runner.generateCode({
                    schema: schemaContent,
                    language: 'cpp',
                });

                if (result.files && Object.keys(result.files).length > 0) {
                    for (const [filename, content] of Object.entries(result.files)) {
                        const outputPath = path.join(OUTPUT_DIR, filename);
                        fs.writeFileSync(outputPath, content);
                        console.log(`  Generated: ${filename}`);
                        generated = true;
                    }
                }
            } catch (e) {
                console.log(`  flatc error: ${e.message}`);
            }
        }

        if (!generated) {
            generateFallbackHeader(schemaName, schemaContent);
        }
    }

    console.log('\n===========================================');
    console.log('Header generation complete!');
    console.log('===========================================');
}

function generateFallbackHeader(schemaName, schemaContent) {
    console.log('  Using fallback header generation...');

    // Parse the schema to extract some structure
    const namespaceMatch = schemaContent.match(/namespace\s+([\w.]+);/);
    const namespace = namespaceMatch ? namespaceMatch[1].replace(/\./g, '::') : 'mcp::protocol';

    const header = `// Auto-generated from FlatBuffers schema: ${schemaName}.fbs
// Generated by generate-headers.mjs
//
// Note: This is a minimal fallback header. For full FlatBuffers support,
// install flatc and run: flatc --cpp schemas/${schemaName}.fbs
#pragma once

#include <cstdint>
#include <cstring>
#include <vector>
#include <string>

namespace ${namespace.replace(/::/g, ' { namespace ')} {

// Position struct
struct Position {
    double longitude = 0;
    double latitude = 0;
    double height = 0;

    Position() = default;
    Position(double lon, double lat, double h = 0)
        : longitude(lon), latitude(lat), height(h) {}
};

// Color struct (RGBA, 0-1 range)
struct Color {
    float red = 1.0f;
    float green = 1.0f;
    float blue = 1.0f;
    float alpha = 1.0f;

    Color() = default;
    Color(float r, float g, float b, float a = 1.0f)
        : red(r), green(g), blue(b), alpha(a) {}
};

// Error codes (from JSON-RPC)
enum class ErrorCode : int32_t {
    ParseError = -32700,
    InvalidRequest = -32600,
    MethodNotFound = -32601,
    InvalidParams = -32602,
    InternalError = -32603
};

// Tool argument types
struct FlyToArgs {
    double longitude = 0;
    double latitude = 0;
    double height = 10000;
    double duration = 2.0;
};

struct AddSphereArgs {
    double longitude = 0;
    double latitude = 0;
    double height = 0;
    double radius = 1000;
    std::string name;
    std::string color;
};

struct AddBoxArgs {
    double longitude = 0;
    double latitude = 0;
    double height = 0;
    double dimensions_x = 1000;
    double dimensions_y = 1000;
    double dimensions_z = 1000;
    std::string name;
    std::string color;
};

struct ResolveLocationArgs {
    std::string location;
};

struct FlyToLocationArgs {
    std::string location;
    double height = 0;
    double duration = 2.0;
};

struct AddSphereAtLocationArgs {
    std::string location;
    double radius = 1000;
    std::string color;
    std::string name;
    double height = 0;
};

// Tool result
struct ToolResult {
    std::string text;
    bool is_error = false;
};

// Resource content
struct ResourceContent {
    std::string uri;
    std::string mime_type;
    std::string text;
};

${Array(namespace.split('::').length).fill('} ').join(' ')} // end namespace ${namespace}
`;

    const outputPath = path.join(OUTPUT_DIR, `${schemaName}_generated.h`);
    fs.writeFileSync(outputPath, header);
    console.log(`  Generated: ${schemaName}_generated.h (fallback)`);
}

main().catch(console.error);
