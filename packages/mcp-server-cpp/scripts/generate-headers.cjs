#!/usr/bin/env node
/**
 * Generate C++ headers from FlatBuffers schema using flatc-wasm
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const PROJECT_DIR = path.dirname(__dirname);
const SCHEMAS_DIR = path.join(PROJECT_DIR, 'schemas');
const OUTPUT_DIR = path.join(PROJECT_DIR, 'include', 'generated');

async function main() {
    console.log('===========================================');
    console.log('Generating C++ headers from FlatBuffers');
    console.log('===========================================\n');

    // Create output directory
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // Find all .fbs files
    const schemaFiles = fs.readdirSync(SCHEMAS_DIR)
        .filter(f => f.endsWith('.fbs'))
        .map(f => path.join(SCHEMAS_DIR, f));

    if (schemaFiles.length === 0) {
        console.log('No .fbs files found in schemas/');
        return;
    }

    console.log(`Found ${schemaFiles.length} schema file(s):`);
    schemaFiles.forEach(f => console.log(`  - ${path.basename(f)}`));
    console.log('');

    // Try to use flatc-wasm
    try {
        // Import flatc-wasm
        let flatc;
        try {
            flatc = require('flatc-wasm');
        } catch (e) {
            console.log('flatc-wasm not found, installing...');
            execSync('npm install flatc-wasm', { cwd: path.join(PROJECT_DIR, '..', '..'), stdio: 'inherit' });
            flatc = require('flatc-wasm');
        }

        // Initialize flatc
        await flatc.ready;

        for (const schemaPath of schemaFiles) {
            const schemaName = path.basename(schemaPath, '.fbs');
            console.log(`Processing: ${schemaName}.fbs`);

            // Read schema content
            const schemaContent = fs.readFileSync(schemaPath, 'utf-8');

            // Compile to C++ header
            try {
                const result = flatc.compile({
                    schema: schemaContent,
                    lang: 'cpp',
                    genAll: true,
                });

                if (result.files) {
                    for (const [filename, content] of Object.entries(result.files)) {
                        const outputPath = path.join(OUTPUT_DIR, filename);
                        fs.writeFileSync(outputPath, content);
                        console.log(`  Generated: ${filename}`);
                    }
                }
            } catch (compileError) {
                console.error(`  Error compiling ${schemaName}: ${compileError.message}`);
            }
        }

        // Also generate JSON schema for x-flatbuffers
        console.log('\nGenerating JSON schemas...');
        for (const schemaPath of schemaFiles) {
            const schemaName = path.basename(schemaPath, '.fbs');
            const schemaContent = fs.readFileSync(schemaPath, 'utf-8');

            try {
                const result = flatc.compile({
                    schema: schemaContent,
                    lang: 'jsonschema',
                });

                if (result.files) {
                    for (const [filename, content] of Object.entries(result.files)) {
                        const outputPath = path.join(SCHEMAS_DIR, `${schemaName}.schema.json`);
                        fs.writeFileSync(outputPath, content);
                        console.log(`  Generated: ${schemaName}.schema.json`);
                    }
                }
            } catch (e) {
                // JSON schema generation might not work for all schemas
                console.log(`  Skipping JSON schema for ${schemaName}: ${e.message}`);
            }
        }

    } catch (error) {
        console.error('Error with flatc-wasm:', error.message);
        console.log('\nFalling back to manual header generation...');

        // Generate a minimal header manually
        generateMinimalHeaders(schemaFiles);
    }

    console.log('\n===========================================');
    console.log('Header generation complete!');
    console.log('===========================================');
}

function generateMinimalHeaders(schemaFiles) {
    // Generate a basic header that defines the types
    // This is a fallback when flatc-wasm isn't available

    const header = `// Auto-generated from FlatBuffers schema
// Generated by generate-headers.js
#pragma once

#include <cstdint>
#include <cstring>

namespace mcp {
namespace protocol {

// Position struct
struct Position {
    double longitude;
    double latitude;
    double height;

    Position() : longitude(0), latitude(0), height(0) {}
    Position(double lon, double lat, double h = 0)
        : longitude(lon), latitude(lat), height(h) {}
};

// Color struct (RGBA, 0-1 range)
struct Color {
    float red;
    float green;
    float blue;
    float alpha;

    Color() : red(1), green(1), blue(1), alpha(1) {}
    Color(float r, float g, float b, float a = 1)
        : red(r), green(g), blue(b), alpha(a) {}
};

// Error codes
enum class ErrorCode : int32_t {
    ParseError = -32700,
    InvalidRequest = -32600,
    MethodNotFound = -32601,
    InvalidParams = -32602,
    InternalError = -32603
};

}  // namespace protocol
}  // namespace mcp
`;

    const outputPath = path.join(OUTPUT_DIR, 'mcp_protocol_generated.h');
    fs.writeFileSync(outputPath, header);
    console.log(`  Generated: mcp_protocol_generated.h (minimal)`);
}

main().catch(console.error);
